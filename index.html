<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Cs240-parallel-applications by jroesch</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>CMPSC 240</h1>
        <p>A description of HaXL from Facebook</p>

        <!-- <p class="view"><a href="https://github.com/jroesch/cs240-parallel-applications">View the Project on GitHub <small>jroesch/cs240-parallel-applications</small></a></p>


        <ul>
          <li><a href="https://github.com/jroesch/cs240-parallel-applications/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/jroesch/cs240-parallel-applications/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/jroesch/cs240-parallel-applications">View On <strong>GitHub</strong></a></li>
        </ul> -->
      </header>
      <section>
        <h1>HaXL</h1>
          <p>
          HaXL is a domain specific language that is being used to fight spam at Facebook.
          It is designed specifically for so called site-integretity engineers to write spam rules.
          Most rules require engineers to query Facebook's numerous data stores and make decisions based
          on how to react to possible incoming spam. Their original solution was FXL a custom rule interpreter. 
          It unfortunately suffered from a variety of problems. Most importantly as a seperate language
          it limited the power and efficency of the language, in comparsion to those that are well proven.
          
          Simon Marlow is one of the core contributors to Haskell, and decided that Haskell would be a great
          fit for doing this. Equipping engineers with the ability to write rules, but also be able to
          encode general purpose buissness logic, all while ignoring the data layer.
          </p>
          
          <p>
          HaXL is an abstraction layer over data sources, and hides the details of data fetching while still presenting
          an interface of fetching data. The approach they take reifies points at which a program may block on a data
          fetch. 
          </p>
          
          <p>
          Haskell is a language of rich abstractions and supports a notion of Monads which enable a vareity
          of behaviors, but most importantly for HaXL's purposes the idea of a concurrency monad or sometimes
          known as free monad.
          </p>
          
          A monad is anything that satisfies this interface:
          
          <pre><code>
          class (Applicative m) => Monad m where
            return :: a -> m a
            (>>=)  :: m a -> (a -> m b) -> m b
          </code></pre>
          
          HaXL proposes an implementation of this signature that allows one to write programs that rely on data fetches.
          Monads have the often useful property that they provide sequencing of operations, but this is not desirable when
          we want to batch multiple data fetches at once. We then turn to a slightly weaker, but more useful concept of an
          Applicative. An Applicative is super class of our Monad type class meaning that for every Monad we also have
          an Applicative. This signature doesn't necessarily provide useful information about how this gives us what we
          want. Any serious practioner of Haskell knows that Applicative provides a different way to explore the same
          structure of the Monad. In our case it is interesting because Applicative's type signature expresses that its
          arguments have data independence. This allows us to collect intermediate results with having to block on a 
          single call. We can then batch these and execute them together.
          
          Haskell's support for parallelism enables this approach to scale across many machines and many cores. These
          engines operate seperately than from the data storage mechanisms allowing them to shard and distribute this
          approach across many machines without having to deal with state synchronization. It is my impresssion that
          each shard of this service idpently deals with cache coherenece, and otherwise functions completely independently
          
          This approach seems to scale linearly according to the figures presented in Marlow's slides.
          
          SLIDES: http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/31/slides/simon.pdf
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/jroesch">jroesch</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
