<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Cs240-parallel-applications by jroesch</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>CMPSC 240</h1>
        <p>A description of HaXL from Facebook</p>

        <!-- <p class="view"><a href="https://github.com/jroesch/cs240-parallel-applications">View the Project on GitHub <small>jroesch/cs240-parallel-applications</small></a></p>


        <ul>
          <li><a href="https://github.com/jroesch/cs240-parallel-applications/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/jroesch/cs240-parallel-applications/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/jroesch/cs240-parallel-applications">View On <strong>GitHub</strong></a></li>
        </ul> -->
      </header>
      <section>
        <h1>HaXL</h1>
          <p>
          HaXL is a domain specific language for that is initially being used to fight spam at Facebook.
          It is designed specifically for site-integretity engineers to write spam filtering rules.
          To do this these engineers must query Facebook's vast data stores and make decisions based
          on the data. Their original solution was a custom rule interpreter FXL. It written in C++ and
          suffered from a variety of problems. Most importantly as a seperate language it was limited and
          lacked the power and efficency of industrial strength languages and their accompying compilers.
          
          Simon Marlow is one of the core contributors to Haskell, and decided that Haskell would be a great
          fit for doing this. Equipping engineers with the ability to write rules, but also be able to
          encode general purpose buissness logic, all while ignoring the data layer.
          </p>
          
          <p>
          HaXL is an abstraction layer over data sources, and hides the details of data fetching while still presenting
          an interface of fetching data. The approach they take reifies points at which a program may block on a data
          fetch. 
          </p>
          
          <p>
          Haskell is a language of rich abstractions and supports a notion of Monads which enable a vareity
          of behaviors, but most importantly for HaXL's purposes the idea of a concurrency monad or sometimes
          known as free monad.
          </p>
          
          A monad is anything that satisfies this interface:
          
          <pre><code>
          class Monad m where
            return :: a -> m a
            (>>=)  :: m a -> (a -> m b) -> m b
          </code></pre>
          
          HaXL proposes an implementation of this signature that allows one to write programs that rely on data fetches.
          
          <pre><code>
            newtype Haxl a = Haxl { unHaxl :: Result a }
            data Result a = Done a 
                          | Blocked (Haxl a)
            instance Monad Haxl where
              return a = Haxl (Done a)
              m >>= k = Haxl $
                case unHaxl m of
                  Done a -> unHaxl (k a)
                  Blocked r -> Blocked (r >>= k)
          </code></pre>
          
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/jroesch">jroesch</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
